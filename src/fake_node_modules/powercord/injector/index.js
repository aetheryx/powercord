"use strict";

const { performance } = require('perf_hooks');

window.__$$injectorRuns = [];
window.__$$injectorRecord = false;

const injectionsById = new Map();

const injector = {
  get injections() { return [...injectionsById.values()]; },

  /**
   * Injects into a function
   * @param {String} injectionId ID of the injection, used for uninjecting
   * @param {object} module Module we should inject into
   * @param {String} funcName Name of the function we're aiming at
   * @param {function} patch Function to inject
   * @param {Boolean} pre Whether the injection should run before original code or not
   */
  inject: (injectionId, module, funcName, patch, pre = false) => {
    if (!module) {
      return injector._error(`Tried to patch undefined (Injection ID "${injectionId}")`);
    }

    // todo: maybe get rid of this thanks to more deserialize magic?
    if (module.__$$remotePrototype) {
      module = module.__$$remotePrototype;
    }

    if (injectionsById.has(injectionId)) {
      return injector._error(`Injection ID "${injectionId}" is already used!`);
    }

    let preInjections;
    let postInjections;
    if (module.__powercordInjections?.[funcName] === undefined) {
      // 1st injection

      preInjections = [];
      postInjections = [];
      const originalMethod = module[funcName];

      module.__powercordInjections ??= {};
      module.__powercordInjections[funcName] = { preInjections, postInjections }

      module[`__powercordOriginal_${funcName}`] = originalMethod; // To allow easier debugging

      module[funcName] = injector._createHook(originalMethod, preInjections, postInjections);
    }
    else {
      ({ preInjections, postInjections } = module.__powercordInjections[funcName]);
    }

    const injection = {
      module,
      funcName,
      id: injectionId,
      method: patch,
      pre
    };

    injectionsById.set(injectionId, injection);
    (pre ? preInjections : postInjections).push(injection);
  },

  /**
   * Removes an injection
   * @param {String} injectionId The injection specified during injection
   */
  uninject: (injectionId) => {
    const injection = injectionsById.get(injectionId);
    if(injection !== undefined) {
      const functionInjections = injection.module.__powercordInjections[injection.funcName];
      injector._arrayRemoveSingle(injection.pre ? functionInjections.preInjections : functionInjections.postInjections, injection);
    }
  },

  /**
   * Check if a function is injected
   * @param {String} injectionId The injection to check
   */
  isInjected: (injectionId) => injectionsById.has(injectionId),

  _arrayRemoveSingle: (array, elementToRemove) => {
    const index = array.indexOf(elementToRemove);
    if(index !== -1) {
      array.splice(index, 1);
    }
  },

  _createHook: (originalMethod, preInjections, postInjections) => {
    return function () {
      if(window.__$$injectorRecord) {
        const startTime = performance.now();
        const finalArgs = injector._runPreInjections(preInjections, arguments, this);
        const stopped = typeof finalArgs === 'number';
        let result;
        let callDuration = 0;
        if (!stopped) {
          const beforeCallTime = performance.now();
          const originalResult = originalMethod?.apply(this, finalArgs);
          const afterCallTime = performance.now();
          callDuration = afterCallTime - beforeCallTime;
  
          // [Cynthia] I think (?) some of the crashes are due to functions injected in the runtime (such as onClick)
          // which may throw an error and cause the thing to fail catastrophically. One fix would be to build a deep
          // proxy of `originalResult`, and in the `set` handler wrap potentially sensitive stuff in a try/catch block.
  
          result = injector._runInjections(postInjections, finalArgs, originalResult, this);
        }

        const endTime = performance.now();
        if (window.__$$injectorRecord) {
          let ranPreInjections = preInjections;
          let ranPostInjections = postInjections;
          if(stopped) {
            const stoppedAt = finalArgs;
            ranPreInjections = preInjections.slice(0, stoppedAt + 1);
            ranPostInjections = [];
          }

          window.__$$injectorRuns.push({
            preIds: ranPreInjections.map(x => x.id),
            postIds: ranPostInjections.map(x => x.id),
            duration: endTime - startTime - callDuration
          });
        }

        return result;
      }
      else {
        const finalArgs = injector._runPreInjections(preInjections, arguments, this, originalMethod);

        if (typeof finalArgs !== 'number') {
          const originalResult = originalMethod?.apply(this, finalArgs);
  
          return injector._runInjections(postInjections, finalArgs, originalResult, this);
        }
      }
    };
  },

  _runPreInjections: (injections, originArgs, _this) => {
    if (injections.length === 0) {
      return originArgs;
    }

    let args = originArgs;
    for (let injectionIndex = 0; injectionIndex < injections.length; injectionIndex++) {
      const injection = injections[injectionIndex];
      let newArgs;
      try {
        newArgs = injection.method.call(_this, args);
      } catch (e) {
        injector._error(`Failed to run pre-injection "${injection.id}"`, e);
        continue;
      }
  
      if (newArgs === false) {
        return injectionIndex;
      }
  
      if (Array.isArray(newArgs)) {
        args = newArgs;
      }
      else {
        injector._error(`Pre-injection ${injection.id} returned something invalid. Return value will be ignored.`);
      }
    }
    return args;
  },

  _runInjections: (injections, originArgs, originReturn, _this) => {
    let finalReturn = originReturn;
    for (const injection of injections) {
      try {
        finalReturn = injection.method.call(_this, originArgs, finalReturn);
      } catch (e) {
        injector._error(`Failed to run injection "${injection.id}"`, e);
      }
    }
    return finalReturn;
  },

  _error: (...args) => {
    console.error('%c[Powercord:Injector]', 'color: #7289da', ...args);
  }
};

/** @module powercord/injector */
module.exports = injector;
